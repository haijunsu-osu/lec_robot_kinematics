\section{Forward kinematics}

\subsection{Workspace}
\textbf{Kinematics} is the science of motion that treats motion without regard to the forces which cause it. One studies position, velocity, acceleration, and all higher order derivatives of position variables.

The existence or nonexistence of a kinematic solution defines the \textbf{workspace} of a given manipulator~\cite{McCarthy2011}. If a solution doesn't exist, this means that the desired position/orientation lies outside of the manipulator's workspace. In other words, the workspace consists of all points that are reachable by the end-effector.

\subsubsection{Configuration}

The \textbf{configuration} of a moving object is a specification of the position of \textbf{every} point on the object~\cite{Lynch2017}. 

The \textbf{dimension of a config space} is the minimum number of parameters needed to specify the configuration of the object completely (also called the number of degrees of freedom of a moving object).

\subsubsection{Degrees of freedom}
The number of \textbf{degrees of freedom} that a manipulator possesses is the number of independent position variables that would have to be specified in order to locate all parts of the mechanism. E.g., industrial robotic manipulators often have as many d.o.f. as their number of joints, since each joint has one d.o.f. (and has 5 constraints).

\subsubsection{Right-hand-rule}
The signs of angles are determined by the direction of the fingers, when the thumb is pointing in the axis direction. Fingers also show the order of axis.

\begin{center}
	\includegraphics[width=5cm]{imgs/2_right_hand_rule.png}
\end{center}

\subsection{Spatial descriptions}

We attach a coordinate system to a body and give a description of this coordinate system relative to the reference system. In Figure 2.2, system $B$ has been attached to the body, and its description relative to $A$ is given through its positions and orientation relative to $A$. 

\begin{center}
	\includegraphics[width=9cm]{imgs/2.png}
\end{center}

\subsubsection{Position}
\textbf{Description of a position:} Since many coordinate systems will be used, one has to define to which system a vector refers, e.g.,

\[^{A}\vect{p} = 
	\begin{bmatrix} p_x\\p_y\\p_z \end{bmatrix}, \] where $^{A}\vect{p}$ is a vector referring to coordinate system $A$.

\subsubsection{Orientation}
\textbf{Description of an orientation:} 
We stack three unit vectors (they specify the principal directions of the coord system) as columns, yielding the \textbf{rotation matrix:} 

\begin{center}
	$^{A}_{B}R = [^{A}\hat{X}_{B}\ ^{A}\hat{Y}_{B}\ ^{A}\hat{Z}_{B}] = \begin{bmatrix} r_{11} & r_{12} & r_{13} \\ r_{21} & r_{22} & r_{23} \\ r_{31} & r_{32} & r_{33} \end{bmatrix} =\ ^{B}_{A} R^{-1} =\ ^{B}_{A} R^T$
\end{center}
The rotation matrix has three constraints:
\begin{itemize}
	\item $|^{A}\hat{X}_{B}| = |^{A}\hat{Y}_{B}| = |^{A}\hat{Z}_{B}| = 1$
	\item $^{A}\hat{X}_{B} \cdot\ ^{A}\hat{Y}_{B} =\ ^{A}\hat{X}_{B} \cdot\ ^{A}\hat{Z}_{B} =\ ^{A}\hat{X}_{B} \cdot\ ^{A}\hat{Z}_{B} = 0$
	\item $\det{R} = 1$
\end{itemize}	
	
It describes the orientation of frame $B$ relative to frame $A$, i.e. it is used as a \textit{mapping} to \textbf{change the description of a vector from frame to frame}. Since we have unit magnitude and the vectors are orthogonal, the transposed matrix describes the orientation of system A written in B. These are orthonormal and length-preserving linear transformations. Also, rotation matrices preserve angles between vectors, i.e. $cos(\angle (\vect{p}, \vect{q})) = cos(\angle (R\vect{p}, R\vect{q}))$. The projection of a vector $\hat{X}_B$ in coord system $B$ into coord system $A$ is derived from the dot product with the principal directions of the coord frame of $A$, hence the graphic.
	
\begin{center}
	\includegraphics[width=9cm]{imgs/2_rotation_matrix.png}
\end{center}

Besides mappings, another use case of rotation matrices is in the form of (rotational)\textit{operators} to move points within the same frame.

Python script example based on SciPy and NumPy:
\begin{lstlisting}[language=Python]
import numpy as np
from scipy.spatial.transform import Rotation as R

# Create a random rotation
r = R.random()
R_matrix = r.as_matrix()
print("Rotation matrix:")
print(R_matrix)
print("Determinant:", np.linalg.det(R_matrix))
print("R^T R:", np.dot(R_matrix.T, R_matrix))
\end{lstlisting}

\subsubsection{Special rotation matrices}
The special rotation matrices for rotation about the axes are:
\[
R_X(\theta) = \begin{pmatrix}
1 & 0 & 0 \\
0 & \cos\theta & -\sin\theta \\
0 & \sin\theta & \cos\theta
\end{pmatrix},
R_Y(\theta) = \begin{pmatrix}
\cos\theta & 0 & \sin\theta \\
0 & 1 & 0 \\
-\sin\theta & 0 & \cos\theta
\end{pmatrix},
R_Z(\theta) = \begin{pmatrix}
\cos\theta & -\sin\theta & 0 \\
\sin\theta & \cos\theta & 0 \\
0 & 0 & 1
\end{pmatrix}
\]

\begin{lstlisting}[language=Python]
# Rotation about x by 45 degrees
r_X = R.from_rotvec([np.pi/4, 0, 0])
print("R_X(45 degrees):")
print(r_X.as_matrix())

# Similarly for y and z
r_Y = R.from_rotvec([0, np.pi/4, 0])
r_Z = R.from_rotvec([0, 0, np.pi/4])
\end{lstlisting}

\subsubsection{Composition of rotations}
A rigid body is subject to 2 or more consecutive rotations, defined by $[R_1], [R_2], \dots$. The final rotation $[R]$ is defined by the product of these matrices. Depending on the reference coordinate system, there are two cases:
\begin{itemize}
\item{Intrinsic}: the 2nd rotation is about the axes of the body-fixed coordinate system, $[R] = [R_1][R_2]$

\item{Extrinsic}: the 2nd rotation is about the global coordinate system, $[R] = [R_2][R_1]$
\end{itemize}

\begin{lstlisting}[language=Python]
# Define two rotations
r1 = R.from_rotvec([np.pi/6, 0, 0])  # 30 degrees about x
r2 = R.from_rotvec([0, np.pi/4, 0])  # 45 degrees about y

# Intrinsic composition: [R] = [R1][R2]
r_intrinsic = r1 * r2
print("Intrinsic rotation matrix:")
print(r_intrinsic.as_matrix())

# Extrinsic composition: [R] = [R2][R1]
r_extrinsic = r2 * r1
print("Extrinsic rotation matrix:")
print(r_extrinsic.as_matrix())
\end{lstlisting}


\subsubsection{Euler angles}
There is an issue when expressing orientations with a rotation matrix: When attempting to follow a trajectory in space by interpolating a current orientation from a start until a final orientation, the intermediary orientations are going to violate the constraints of the rotation matrix. Another possible description of a frame $B$ uses a \textit{three-angle-representation}. It works as follows: Frame $B$ coincides with a known frame $A$. Rotate $B$ first
\begin{itemize}
	\item about $ \hat{X}_{A} $ by an angle \(\gamma\), then about
	\item $ \hat{Y}_{A} $ by an angle \(\beta\), and finally about
	\item $ \hat{Z}_{A} $ by \(\alpha\).
\end{itemize}
If, each of the three rotations takes place about an axis in the fixed reference frame $A$, we call these angles \textit{X-Y-Z fixed angles}. An alternative representation uses angles that are relative to the previously changed coordinate frame, so-called \textbf{Euler angles}.

\begin{center}
	\includegraphics[width=10cm]{imgs/2_fixed_relative_angles.png}
\end{center}

The next figure shows three subsequent rotations of a frame around the fixed axes $\hat X_A$, $\hat Y_A$ and $\hat Z_A$.

\begin{center}
	\includegraphics[width=10cm]{imgs/9.png}
\end{center}

The combined rotation matrix is $^{A}_{B}R =\ ^{A}_{B'}R \cdot \ ^{B'}_{B''}R \cdot \ ^{B''}_{B}R$, which is cumbersome to compute. Instead, we define:

\begin{align*}
{ }_{B}^{A} R_{X Y Z}(\gamma, \beta, \alpha) &=R_{Z}(\alpha) R_{Y}(\beta) R_{X}(\gamma) \\
&=\left[\begin{array}{ccc}
\cos \alpha & -\sin \alpha & 0 \\ \sin \alpha & c \alpha & 0 \\ 0 & 0 & 1
\end{array}\right]\left[\begin{array}{ccc}
\cos \beta & 0 & \sin \beta \\ 0 & 1 & 0 \\ -\sin \beta & 0 & \cos \beta
\end{array}\right]\left[\begin{array}{ccc} 1 & 0 & 0 \\ 0 & \cos \gamma & -\sin \gamma \\
0 & \sin \gamma & \cos \gamma
\end{array}\right] \\
&= \left[\begin{array}{ccc}
\cos \alpha \cos \beta & \cos \alpha \sin \beta \sin \gamma-\sin \alpha \cos \gamma & \cos \alpha \sin \beta \cos \gamma+\sin \alpha \sin \gamma \\
\sin \alpha \cos \beta & \sin \alpha \sin \beta \sin \gamma+\cos \alpha \cos \gamma & \sin \alpha \sin \beta \cos \gamma-\cos \alpha \sin \gamma \\
-\sin \beta & \cos \beta \sin \gamma & \cos \beta \cos \gamma
\end{array}\right]
\end{align*}

When rotating a frame with Euler angles in the order of $Z$-$Y$-$X$, they produce the same combined rotation as $X$-$Y$-$Z$ fixed angles, i.e. $R_{Z^{\prime} Y^{\prime} X^{\prime}}(\alpha, \beta, \gamma)=R_{X Y Z}(\gamma, \beta, \alpha)$ for the same values of $(\alpha, \beta, \gamma)$. This next graphic shows the rotation using Euler angles:

\begin{center}
	\includegraphics[width=10cm]{imgs/2_euler_angles.png}
\end{center}

\textbf{Inverse problem:} Given $^{A}_{B}R$ find the $X$-$Y$-$Z$ fixed angles $(\alpha, \beta, \gamma)$. Let
\[{ }_{B}^A R_{X Y Z}(\gamma, \beta, \alpha)=\left[\begin{array}{lll}
r_{11} & r_{12} & r_{13} \\
r_{21} & r_{22} & r_{23} \\
r_{31} & r_{32} & r_{33}
\end{array}\right] \]

If $\cos \beta \neq 0$,
\begin{align*}
&\beta_1 = \arcsin(-r_{31}), \beta_2 = \pi - \arcsin(-r_{31}) \\
&\alpha_i=\operatorname{atan2}\left(r_{21} / \cos \beta_i, r_{11} / \cos \beta_i\right) \\
&\gamma_i=\operatorname{atan2}\left(r_{32} / \cos \beta_i, r_{33} / \cos \beta_i\right)
\end{align*}
See the definition of $\operatorname{atan2}(a, b)$ in the Appendix.

If $\cos \beta = 0$, this is a singularity (gimbal lock), we have infinite solutions of $\alpha$ and $\gamma$. There are two possible solution sets:
\begin{align*}
&\beta_1 = \pi/2, \quad \gamma_1 - \alpha_1 = \operatorname{atan2}(r_{12}, r_{13}) \\
&\beta_2 = -\pi/2, \quad \gamma_2 + \alpha_2 = \operatorname{atan2}(-r_{12}, -r_{13})
\end{align*}


There are 12 different Euler angle conventions, which arise from the different possible sequences of axis rotations (choosing which axes to rotate about and in what order). The examples given below are for intrinsic Euler angles, where each subsequent rotation is performed relative to the body's current orientation. There are 12 sets of intrinsic Euler angle conventions:

\begin{itemize}
\item \textbf{Proper Euler angles:} These are Euler angle sequences where the first and third rotations are performed about the same axis. The middle rotation is about a different axis.
  \begin{itemize}
  \item z-x-z, \quad x-y-x,\quad y-z-y, \quad z-y-z, \quad x-z-x, \quad y-x-y
  \end{itemize}
\item \textbf{Taitâ€“Bryan angles:} These are Euler angle sequences where all three rotations are performed about different axes, providing a complete set of three distinct axes.
  \begin{itemize}
  \item x-y-z, \quad y-z-x, \quad z-x-y, \quad x-z-y, \quad z-y-x, \quad y-x-z
  \end{itemize}
\end{itemize}
The corresponding extrinsic Euler angle sets are the reverse sequences. For instance, the extrinsic version of the intrinsic X-Y-Z is Z-Y-X. See \ref{subsec:euler_angles_appendices} in the Appendices for all 12 sets of intrinsic Euler angles and their corresponding rotation matrices~\cite{Craig2005}.

\textbf{Example: x-y-z (intrinsic)}: Let $\alpha, \beta, \gamma$ be the Euler angles of three consecutive rotations in the sequence of $x_0$, $y_1$ and $z_2$, where the subscripts indicate the coorindate system the rotation is about.

\[
[R(\alpha,\beta,\gamma)]_{xyz} = R_X(\alpha) R_Y(\beta) R_Z(\gamma)   
\]
\[= \begin{pmatrix}
\cos\beta\cos\gamma & -\cos\beta\sin\gamma & \sin\beta \\
\sin\alpha\sin\beta\cos\gamma + \sin\gamma\cos\alpha & -\sin\alpha\sin\beta\sin\gamma + \cos\alpha\cos\gamma & -\sin\alpha\cos\beta \\
\sin\alpha\sin\gamma - \sin\beta\cos\alpha\cos\gamma & \sin\alpha\cos\gamma + \sin\beta\sin\gamma\cos\alpha & \cos\alpha\cos\beta
\end{pmatrix}\]

\textbf{Inverse Kinematics:}
For the intrinsic x-y-z sequence, the angles can be recovered from $[R]$ as follows:
\begin{align*}
&\beta_1 = \arcsin(r_{13}), \beta_2 = \pi - \arcsin(r_{13}) \\
&\alpha_i = \mathrm{atan2}(\sin\alpha, \cos\alpha) = \mathrm{atan2}\left(-\frac{r_{23}}{\cos\beta_i}, \frac{r_{33}}{\cos\beta_i}\right) \\
&\gamma_i = \mathrm{atan2}(\sin\gamma, \cos\gamma) = \mathrm{atan2}\left(-\frac{r_{12}}{\cos\beta_i}, \frac{r_{11}}{\cos\beta_i}\right)
\end{align*}
	
This gives two sets of solutions: $(\alpha_1, \beta_1, \gamma_1)$ and $(\alpha_2, \beta_2, \gamma_2)$. When $\cos\beta = 0$ (gimbal lock), $\gamma$ and $\alpha$ are not independent. Use the similar formulas as above to compute $\beta$ and $\gamma - \alpha$ or $\gamma + \alpha$ as shown in the previous example.


\begin{lstlisting}[language=Python]
import numpy as np
from scipy.spatial.transform import Rotation as R

# Given Euler angles (alpha, beta, gamma) in radians
original_angles = np.array([0.1, 0.2, 0.3])  # example values

# Generate rotation matrix from Euler angles
r_original = R.from_euler('xyz', original_angles)
R_matrix = r_original.as_matrix()
print("Rotation matrix from original angles:")
print(R_matrix)

# Now, use inverse kinematics to extract Euler angles
extracted_angles = r_original.as_euler('xyz', degrees=False)
print("Extracted Euler angles (alpha, beta, gamma):")
print(extracted_angles)

# Check if they match (within numerical precision)
difference = np.abs(original_angles - extracted_angles)
print("Difference between original and extracted:")
print(difference)
print("Are they close?", np.allclose(original_angles, extracted_angles))
\end{lstlisting}


\subsubsection{Rotation axis and angle}
Every rotation has an axis, which is the set of points that remain invariant (fixed) under the rotation transformation. The geometric properties of rotation axes are fundamental in understanding spatial rotations~\cite{McCarthy2011}.

\textbf{Definition:} The points that remain fixed during a rotation $[R]$ form its \textbf{rotation axis}. To find these points, we consider the transformation equation
\[ X = [R]X \]

This shows that a fixed point $X$ is the solution to
\[ ([I] - [R])X = 0 \]

For there to be solutions other than $X = 0$, the determinant of the coefficient matrix must be zero: $\det([I] - [R]) = 0$. This condition is satisfied for all spatial rotation matrices, meaning that rotation matrices always have $\lambda = 1$ as an eigenvalue. If $K$ is a nonzero solution, then every point $P = tK$ on the line through the origin and $K$ is also a solution. This line of points is the \textbf{rotation axis}.

\textbf{Cayley's formula:} To obtain an explicit equation for the rotation axis, we use Cayley's formula. Consider the points $x$ and $X$ that represent the initial and final positions obtained from the rotation $X = [R]x$. Using the fact that $|x| = |X|$ (rotation preserves distances), we can show that
\[ X - x = b \times (X + x) \]

where $\times$ denotes the vector cross product, and $b$ is \textbf{Rodrigues's vector}. This vector can be computed from the rotation matrix using
\[ [B] = ([R] - [I])([R] + [I])^{-1} \]

where $[B]$ is the skew-symmetric matrix associated with $b = (b_x, b_y, b_z)^T$:
\[ [B] = \begin{bmatrix}
0 & -b_z & b_y \\
b_z & 0 & -b_x \\
-b_y & b_x & 0
\end{bmatrix} \]

The skew-symmetric matrix $[B]$ has the property that for any vector $y$,
\[ [B]y = b \times y \]

Cayley's formula for the rotation matrix in terms of $[B]$ is:
\[ [R] = ([I] - [B])^{-1}([I] + [B]) \]

To find the rotation axis explicitly, we solve $([I] - [R])X = 0$. Substituting Cayley's formula:
\[ \left([I] - ([I] - [B])^{-1}([I] + [B])\right)X = 0 \]

which simplifies to
\[ [B]X = 0 \]

Since $[B]X = b \times X$, it is clear that $X = b$ is a solution. Thus, \textbf{Rodrigues's vector $b$ defines the rotation axis direction}.

We denote by $K = (k_x, k_y, k_z)^T$ the unit vector in the direction of Rodrigues's vector $b$, which identifies the rotation axis. The magnitude of Rodrigues's vector is related to the rotation angle $\theta$ by
\[ b = \tan\left(\frac{\theta}{2}\right) K \]

Therefore, the rotation axis can be extracted from a rotation matrix by:
\begin{enumerate}
\item Compute the skew-symmetric matrix $[B] = ([R] - [I])([R] + [I])^{-1}$
\item Extract the vector $b = (b_x, b_y, b_z)^T$ from $[B]$
\item Normalize $b$ to obtain the unit rotation axis: $K = \frac{b}{|b|}$
\item Compute the rotation angle: $\theta = 2\arctan(|b|)$
\end{enumerate}

The rotation matrix can also be expressed explicitly in terms of its rotation axis $K$ and angle $\theta$ using:
\[ [R(\theta, K)] = [I] + \sin\theta [K] + (1 - \cos\theta)[K]^2 \]

where $[K]$ is the skew-symmetric matrix associated with the unit vector $K$.

\begin{lstlisting}[language=Python]
import numpy as np
from scipy.spatial.transform import Rotation as R

# Example: Extract rotation axis and angle from a rotation matrix
# Create a rotation: 45 degrees around axis [1, 1, 1]
axis = np.array([1, 1, 1])
axis = axis / np.linalg.norm(axis)  # normalize
angle = np.pi / 4  # 45 degrees

r = R.from_rotvec(angle * axis)
R_matrix = r.as_matrix()

print("Rotation matrix:")
print(R_matrix)

# Method 1: Using scipy to extract axis-angle
rotvec = r.as_rotvec()
extracted_angle = np.linalg.norm(rotvec)
extracted_axis = rotvec / extracted_angle if extracted_angle != 0 else rotvec

print("\nExtracted rotation axis K:", extracted_axis)
print("Extracted rotation angle (radians):", extracted_angle)
print("Extracted rotation angle (degrees):", np.degrees(extracted_angle))

# Method 2: Using Cayley's formula (manual computation)
I = np.eye(3)
# Compute [B] = ([R] - [I])([R] + [I])^{-1}
try:
    B = (R_matrix - I) @ np.linalg.inv(R_matrix + I)
    # Extract b from skew-symmetric matrix
    b = np.array([B[2, 1], B[0, 2], B[1, 0]])
    b_magnitude = np.linalg.norm(b)
    K_cayley = b / b_magnitude
    theta_cayley = 2 * np.arctan(b_magnitude)
    
    print("\nUsing Cayley's formula:")
    print("Rodrigues vector b:", b)
    print("Rotation axis K:", K_cayley)
    print("Rotation angle (radians):", theta_cayley)
    print("Rotation angle (degrees):", np.degrees(theta_cayley))
except:
    print("\nCayley's formula computation failed (singular case)")
\end{lstlisting}


\subsubsection{Unit quaternions}
Another representation of orientation is by means of four values called the \textbf{Quaternions}. It can be shown that every rotation can be expressed as one rotation of $\theta$ around a single axis $K = [k_x\ k_y\ k_z]^T$. This is also known as the \textit{equivalent angle-axis representation}. 

\begin{center}
	\includegraphics[width=4cm]{imgs/2_equivalent_angle_axis.png}
\end{center}

The quaternions are defined by

\[ (\varepsilon_1 , \varepsilon_2 , \varepsilon_3 , \varepsilon_4) = ( k_{x} \sin \frac{\theta}{2}, k_{y} \sin \frac{\theta}{2}, k_{z} \sin \frac{\theta}{2}, \cos \frac{\theta}{2})  \]

and 
\[ \epsilon_{1}^{2}+\epsilon_{2}^{2}+\epsilon_{3}^{2}+\epsilon_{4}^{2}=1 \]

This $4 \times 1$ vector is known as a unit quaternion, the orientation it describes could be visualized as a point on a unit hypersphere in four-dimensional space. It turns out that the orientation representation through Euler parameters does not have a singularity.


\subsection{Spatial transformations}
\textit{Problem:} We know the definition of a vector with respect to some frame $B$ and we would like to express it with respect to another frame $A$, where the origins of the two frames are coincident. We can compute this, if we know a description of the orientation of $B$ relative to $A$. Then, \[^{A} P = {^{A}_{B}}R\ {^{B}}P \] computes what a \textbf{vector that is expressed in coordinate system B ``looks like'' if observed from system A}.

\begin{center}
	\includegraphics[width=5cm]{imgs/4.png} 
	\includegraphics[width=7cm]{imgs/5.png}	
\end{center}

Now, the \textbf{general case}, where the systems don't have the same origin, but B is shifted by $P_{BORG}$ from the origin (or $^{A}P_{BORG}$ when expressed in $A$):

$$^{A}P =\ ^{A}_{B}R\ ^{B}P + \ ^{A}P_{BORG}\ $$ 

\begin{center}
	\includegraphics[width=6cm]{imgs/6.png}
\end{center}

Computing a position of a point connected by multiple subsequent links of a manipulator with individual coordinate frames, involves the multiplication of sums given by the general transform equation. This is because \textit{rotation} and \textit{translation} are both needed to propagate from one frame to another. To simplify this calculation, a \textbf{homogeneous transform} combines rotation and translation into a matrix $_{B}^{A}T$, such that: ${}^{A}P={}_{B}^{A}T\ ^{B}P$. Therefore, the homogeneous transform is a \textit{general operator}.

\begin{center}
	\includegraphics[width=4cm]{imgs/2_homogeneous_transform.png}
\end{center}

Due to the generality of the homogeneous transform, it can be interpreted in different ways: 1.) as a description of a frame $\{B\}=\{_{B}^{A}R \ \ ^{A}P_{BORG}\}$; 2.) as a mapping of a point in frame $B$ to frame $A$; 3.) as an operator to rotate and translate a point in the same frame. This is an example for the second case:

\begin{center}
	\includegraphics[width=6cm]{imgs/7.png}
	\includegraphics[width=8cm]{imgs/8.png}
\end{center}

\begin{lstlisting}[language=Python]
import numpy as np
from scipy.spatial.transform import Rotation as R

# Homogeneous transformation matrix from frame B to frame A
A_T_B = np.array([
    [0.866, -0.500, 0.000, 10.0],
    [0.500,  0.866, 0.000,  5.0],
    [0.000,  0.000, 1.000,  0.0],
    [0.000,  0.000, 0.000,  1.0]
])

# Point P in frame B (homogeneous coordinates)
B_P = np.array([3.0, 7.0, 0.0, 1.0])

# Transform point into frame A
A_P = A_T_B @ B_P

# Extract just the 3D coordinates
print("\nCoordinates of P in frame A:")
print(A_P[:3])
\end{lstlisting}
 
\subsubsection{Inverse of the homogeneous transform}
The inverse of a homogeneous transform $_{B}^{A}T = [_{B}^{A}R \ \ ^{A}P_{BORG}]$ is given by:
\[ _{A}^{B}T = \begin{bmatrix} { }_{B}^{A}R^{T} & -{ }_{B}^{A}R^{T} \ { }^{A}P_{BORG} \\ 0 & 1 \end{bmatrix} \]

\begin{center}
	\includegraphics[width=7cm]{imgs/2_inverse_transform.png}
\end{center}

\subsubsection{Compound transformations}

When multiple transformations are applied in sequence, the overall transformation can be obtained by multiplying the individual homogeneous transformation matrices. This is known as \textbf{compound transformation}.

\begin{center}
	\includegraphics[width=7cm]{imgs/2_compound_transformation_1.png}
	\includegraphics[width=6cm]{imgs/2_compound_transformation_2.png}
\end{center}

Transform equation: ${}_{B}^{A}T \ {}_{C}^{B}T \ {}_{D}^{C}T \ {}_{A}^{D}T= I$.

\begin{lstlisting}[language=Python]
import numpy as np
from scipy.spatial.transform import Rotation as R

# Define two homogeneous transformations

# Transformation T1: rotation by 30 degrees around z-axis, translation [10, 5, 0]
r1 = R.from_euler('z', np.pi/6)
T1 = np.eye(4)
T1[:3, :3] = r1.as_matrix()
T1[:3, 3] = [10, 5, 0]

# Transformation T2: rotation by 45 degrees around x-axis, translation [2, 3, 1]
r2 = R.from_euler('x', np.pi/4)
T2 = np.eye(4)
T2[:3, :3] = r2.as_matrix()
T2[:3, 3] = [2, 3, 1]

# Compound transformation: T_compound = T1 @ T2
T_compound = T1 @ T2
print("Compound transformation matrix:")
print(T_compound)

# Inverse of the compound transformation
T_inv = np.linalg.inv(T_compound)
print("Inverse transformation matrix:")
print(T_inv)

# Example: Apply compound transformation to a point
P = np.array([1.0, 2.0, 3.0, 1.0])  # Point in homogeneous coordinates
P_transformed = T_compound @ P
print("Point after compound transformation:", P_transformed[:3])

# Apply inverse to get back
P_back = T_inv @ P_transformed
print("Point after applying inverse:", P_back[:3])
\end{lstlisting}

\subsubsection{Screw axis and displacement}

A fundamental result in spatial kinematics, known as \textbf{Chasles' theorem}, states that every spatial displacement can be represented as a rotation about an axis combined with a translation along that same axis. This axis is called the \textbf{screw axis}, and the combined motion is called a \textbf{screw displacement}~\cite{McCarthy2011}.

\textbf{Definition:} While spatial displacements have no fixed points in general, there exists a line, called the \textbf{screw axis}, that remains invariant (fixed in direction and position) during the displacement. A spatial displacement consists of:
\begin{itemize}
\item A rotation by angle $\theta$ about the screw axis
\item A translation by distance $t$ along the screw axis
\end{itemize}

Consider a spatial displacement defined by the homogeneous transform $[T] = [R, d]$, where $[R]$ is the $3 \times 3$ rotation matrix and $d$ is the translation vector. If a point $C$ has the same coordinates before and after the displacement, it must satisfy:
\[ C = [R]C + d \]

which simplifies to:
\[ ([I] - [R])C = d \]

Since all rotation matrices have $\lambda = 1$ as an eigenvalue (meaning $\det([I] - [R]) = 0$), this equation generally has no solution, confirming that spatial displacements have no fixed points. However, we can find a fixed line by decomposing the translation.

\textbf{Computing the screw axis:} The screw axis can be computed by decomposing the translation vector $d$ into components parallel and perpendicular to the rotation axis $K$ of $[R]$:
\[ d = d_{\perp} + tK \]

where:
\begin{itemize}
\item $K = (k_x, k_y, k_z)^T$ is the unit vector defining the rotation axis (computed using methods from the previous section)
\item $t = d \cdot K$ is the translation distance along the screw axis
\item $d_{\perp} = d - tK$ is the component perpendicular to $K$
\end{itemize}

The displacement can now be decomposed as:
\[ [T] = [I, tK][R, d_{\perp}] = [R, d_{\perp} + tK] \]

A point $C$ on the screw axis can be found using Rodrigues's vector $b = \tan(\theta/2)K$ from the rotation matrix $[R]$:
\[ C = \frac{b \times (d_{\perp} - b \times d_{\perp})}{2(b \cdot b)} \]

The screw axis is then the line:
\[ S: P(s) = C + sK \]

where $s$ is a parameter along the line.

\textbf{Screw parameters:} The complete screw displacement is characterized by four parameters:
\begin{enumerate}
\item \textbf{Screw axis direction}: $K = (k_x, k_y, k_z)^T$ (unit vector)
\item \textbf{Point on screw axis}: $C$ (determines axis location)
\item \textbf{Rotation angle}: $\theta$ (rotation about the axis)
\item \textbf{Translation}: $t$ (slide along the axis)
\end{enumerate}

The screw displacement can be expressed as:
\[ [T(\theta, t, K, C)] = [R(\theta, K), ([I] - [R])C + tK] \]

This shows that any point $X$ transforms according to:
\[ X - C = [R(\theta, K)](x - C) + tK \]

which explicitly shows the rotation about point $C$ followed by translation along $K$.

\begin{lstlisting}[language=Python]
import numpy as np
from scipy.spatial.transform import Rotation as R

# Example: Compute screw axis from a spatial displacement
# Define a rotation: 60 degrees around axis [1, 1, 1]
axis = np.array([1, 1, 1])
K = axis / np.linalg.norm(axis)  # normalize to get unit vector
theta = np.deg2rad(60)

r = R.from_rotvec(theta * K)
R_matrix = r.as_matrix()

# Define a translation vector
d = np.array([3.0, 4.0, 5.0])

# Decompose translation into parallel and perpendicular components
t = np.dot(d, K)  # translation along axis
d_perp = d - t * K  # perpendicular component

print("Rotation axis K:", K)
print("Rotation angle (degrees):", np.degrees(theta))
print("Translation along axis t:", t)
print("Perpendicular translation d_perp:", d_perp)

# Find a point C on the screw axis using Rodrigues's vector
I = np.eye(3)
try:
    B = (R_matrix - I) @ np.linalg.inv(R_matrix + I)
    b = np.array([B[2, 1], B[0, 2], B[1, 0]])
    
    # Compute point on screw axis
    if np.linalg.norm(b) > 1e-10:
        C = np.cross(b, (d_perp - np.cross(b, d_perp))) / (2 * np.dot(b, b))
    else:
        # Pure translation case
        C = np.zeros(3)
    
    print("\nPoint on screw axis C:", C)
    
    # Verify: reconstruct the homogeneous transform
    T_reconstructed = np.eye(4)
    T_reconstructed[:3, :3] = R_matrix
    T_reconstructed[:3, 3] = (I - R_matrix) @ C + t * K
    
    print("\nReconstructed translation vector:", T_reconstructed[:3, 3])
    print("Original translation vector:", d)
    print("Match:", np.allclose(T_reconstructed[:3, 3], d))
    
except:
    print("Computation failed (singular case or pure translation)")

# Visualize the screw parameters
print("\n=== Screw Displacement Summary ===")
print(f"Screw axis direction K: [{K[0]:.4f}, {K[1]:.4f}, {K[2]:.4f}]")
print(f"Rotation angle theta: {np.degrees(theta):.2f} degrees")
print(f"Translation along axis t: {t:.4f}")
if 'C' in locals():
    print(f"Point on axis C: [{C[0]:.4f}, {C[1]:.4f}, {C[2]:.4f}]")
\end{lstlisting}

\subsection{Forward kinematics}
Forward kinematics solves the static geometrical problem of computing the position and the orientation of the end-effector of the manipulator. Specifically, given a \textbf{set of joint angles}, the forward kinematic problem is to compute the position and orientation of the tool frame relative to the base frame.

\subsubsection{Denavit-Hartenberg Convention}
The homogeneous transform between consecutive frames of links is represented via only 4 D-H-parameters (x-rot, x-trans, z-trans, z-rot). In general, 6 parameters are needed to represent an arbitrary rigid body transformation! Thus, a restriction of it is, that it \textbf{cannot represent a rotation around the $y$-axis and that the $y$- and $z$-position are coupled}~\cite{Craig2005}.

Procedure for deriving the D-H-parameters:

\begin{center}
	\includegraphics[width=13cm]{imgs/10.png}\\
	\includegraphics[width=7cm]{imgs/2_dh_params.png}
	\includegraphics[width=9cm]{imgs/11.png}
\end{center}

Among the four D-H-parameters are three fixed link parameters and one joint variable, which is $\theta_i$ for a revolute joint or $d_i$ for a prismatic joint. The D-H-parameters are plugged into homogenous transformation matrices, which represent the single transformations between the frames of subsequent links. Then, we can propagate through all homogeneous transformations to calculate the position and orientation of the end-effector. Hereafter, the above described procedure is detailed further:\\

\begin{figure*}[h]
	\centering
	\subfloat[Identify the joint axes; consider axes $i$ and $i-1$. By convention, a joint axis points \textbf{in the direction of the rotation/ movement} for revolute/ prismatic joints.]{\includegraphics[width=.45\textwidth]{imgs/2_dh_1.png}}
	\hfill
	\subfloat[Identify the common perpendicular. If the axes intersect, the common perpendicular is a normal through the plane they span and the direction of $\alpha_i$ is determined by the direction of this normal. \textbf{$a_i$ and $\alpha_i$ describe the $i$th link}. (``We rotate axis $i-1$ around the normal about $\alpha$ so that it coincides with axis $i$. This aligns the $Z$-axes.'')]{\includegraphics[width=.45\textwidth]{imgs/2_dh_2.png}}\\
	\caption{D-H parameters assignment}
\end{figure*}

\begin{figure*}[h]
	\ContinuedFloat
	\centering
	\subfloat[\textbf{$d_i$ and $\theta_i$ describe the $i-1$th link connection}. If the axes of link $i-1$ and link $i$ are parallel, the origin of a coordinate frame $\{i-1\} $ should be attached, such that $d_i=0$. (``$\theta_i$ aligns the $X$-axes by rotation around $Z_i$.'')]{\includegraphics[width=.45\textwidth]{imgs/2_dh_3.png}}
	\hfill
	\subfloat[Attach $i$th frame, such that $\hat Z_i$ is in the direction of the $i$th joint axis and $\hat X_i$ points along the common perpendicular (if $\hat Z_{i-1}$ and $\hat Z_i$ intersect, choose $\hat X_{i-1}$, such that $\alpha_{i-1}>0$). $\hat Y_i$ completes the right-hand frame.]{\includegraphics[width=.45\textwidth]{imgs/2_dh_4.png}}\\
	\caption{(Continued)}
\end{figure*}

\begin{figure}[h]
	\ContinuedFloat 
	\centering
	\subfloat[$a_i$ and $\alpha_i$ depend on joint axes $i$ and $i+1$. Thus, select axes $0$ and $n+1$, such that $a_0=a_n=0$ and $\alpha_0=\alpha_n=0$ (by making axis $0$ coincident with axis $1$ and axis $n+1$ coincident with axis $n$). This simplifies the forward kinematics.]{\includegraphics[width=.45\textwidth]{imgs/2_dh_5.png}}
	\hfill
	\subfloat[$\theta_i$ and $d_i$ depend on joint axes $i$ and $i-1$. Again, select axes $0$ and $n+1$, such that depending on the joint type $a_0$ or $\theta_0=0$ and $a_n$ or $\theta_n=0$ (by coinciding axes and moving the intersection point that becomes the origin of the frame so that $d=0$ or orienting the axis so that $\theta=0$). ]{\includegraphics[width=.45\textwidth]{imgs/2_dh_6.png}}
	\caption{(Continued)}
\end{figure}

\begin{figure}[h]
	\ContinuedFloat 
	\centering
	\subfloat[$\{0\}$ is assigned, such that is equals $\{1\}$ when the first joint variable is $0$.]{\includegraphics[width=.45\textwidth]{imgs/2_dh_7.png}}
	\hfill
	\subfloat[Assign $\{N\}$, such that the most parameters are $0$.]{\includegraphics[width=.45\textwidth]{imgs/2_dh_8.png}}
	\caption{(Continued)}
\end{figure}

\FloatBarrier

Then, the forward kinematics of a single link using the D-H-parameters derive as follows:

\begin{figure}[h]
	\centering
	\subfloat[To obtain $^{i-1}_{i}T$: Translate along $Z_{i}$ about $d_i$ ($\rightarrow \{P\} $), then rotate around $Z_i$ about $\theta_i$ ($\rightarrow \{Q\} $), then translate along $X_{i-1}$ about $a_{i-1}$ ($\rightarrow \{R\} $) and finally rotate around $X_i$ about $\alpha_i$ ($\rightarrow \{i-1\} $). This results in the homogeneous transform for a single link from $\{i\} $ to $\{i-1\} $ and also works in the other direction to compute the inverse homogeneous transform.]{\includegraphics[width=.45\textwidth]{imgs/2_dh_fkin_1.png}}
	\hfill
	\subfloat[The \textbf{homogeneous transformation from link $i$ to link $i-1$} (the formula in the slide should say $i$ instead of $1$).]{\includegraphics[width=.45\textwidth]{imgs/2_dh_fkin_2.png}}\\
	\subfloat[The homogeneous transformation which transforms points from the frame of link $N$ to the frame of link $0$.]{\includegraphics[width=.45\textwidth]{imgs/2_dh_fkin_3.png}}
	
\end{figure}

Note, that the homogeneous transform ${}^{i-1}_iT$ cannot express arbitrary rigid body transformations, since no rotation about $\hat{Y}$ is possible.
A good, practical explanation of how to place the coordinate frames at each link, derive the D-H-parameters and compute the homogeneous transformations and forward kinematics is given in \href{https://youtu.be/u79KfNgP1Cc?t=1939}{this video} (based on an example).


\subsubsection{D-H Parameter Table for Robot Manipulators}

The structural parameters of a serial chain robot manipulator can be described by a table of Denavit-Hartenberg (D-H) parameters. Each row in the table corresponds to a joint/link and specifies four parameters: $a_{i-1}$ (link length), $\alpha_{i-1}$ (link twist), $d_i$ (link offset), and $\theta_i$ (joint angle). These parameters are essential for systematically modeling the kinematics of robot arms.

\textbf{Example: UR5e Robot Arm} The official D-H parameters for the UR5e robot arm are as follows:\footnote{Source: \href{https://www.universal-robots.com/articles/ur/application-installation/dh-parameters-for-calculations-of-kinematics-and-dynamics/}{Universal Robots: Denavit-Hartenberg Parameters}}.The table lists the link lengths ($a_{i-1}$), link twists ($\alpha_{i-1}$), link offsets ($d_i$), and joint angles ($\theta_i$) for each joint of the UR5e. The figure shows the kinematic diagram and the assignment of DH frames for the UR series robots.


\begin{figure}[h]
	\centering
	\begin{minipage}[c]{0.3\textwidth}
		\centering
		\includegraphics[width=0.95\textwidth]{imgs/UR_DH.png}

	\end{minipage}%
	\hfill
	\begin{minipage}[c]{0.48\textwidth}
		\centering
		\captionof{table}{Denavit-Hartenberg Parameters for UR5e}
		\begin{tabular}{|c|c|c|c|c|}
			\hline
			Joint $i$ & $a_{i-1}$ [m] & $\alpha_{i-1}$ [deg] & $d_i$ [m] & $\theta_i$ [deg] \\
			\hline
			1 & 0 & 0 & 0.1625 & $\theta_1$ \\
			2 & -0.425 & 0 & 0 & $\theta_2$ \\
			3 & -0.3922 & 0 & 0 & $\theta_3$ \\
			4 & 0 & 90 & 0.1333 & $\theta_4$ \\
			5 & 0 & -90 & 0.0997 & $\theta_5$ \\
			6 & 0 & 0 & 0.0996 & $\theta_6$ \\
			\hline
		\end{tabular}
		\label{tab:ur5e_dh}

		\vspace{1em}

		\captionof{table}{Modified Denavit-Hartenberg Parameters (DHM) for UR5e (RoboDK)}
		\begin{tabular}{|c|c|c|c|c|}
			\hline
			Joint $i$ & $a_{i}$ [mm] & $\alpha_{i}$ [rad] & $d_{i}$ [mm] & $\theta_{i}$ [rad] \\
			\hline
			1 & 0 & 0 & 162.5 & 0 \\
			2 & 0 & $\frac{\pi}{2}$ & 0 & $\pi$ \\
			3 & 425 & 0 & 0 & 0 \\
			4 & 392.25 & 0 & 133.3 & 0 \\
			5 & 0 & $-\frac{\pi}{2}$ & 99.7 & 0 \\
			6 & 0 & $\frac{\pi}{2}$ & 99.6 & $\pi$ \\
			\hline
		\end{tabular}
		\label{tab:ur5e_dhm}
	\end{minipage}
	\caption{UR5e kinematic diagram (left) and DH parameter tables (right).}
	\label{fig:ur5e_dh}
\end{figure}

The standard Denavit-Hartenberg (DH) parameters use $a_{i-1}$, $\alpha_{i-1}$, $d_i$, and $\theta_i$, while the modified DH (DHM) convention uses $a_i$, $\alpha_i$, $d_i$, and $\theta_i$, with positive link lengths preferred and potential offsets added to $\theta$ for negative lengths. RoboDK, a powerful software for robot simulation, offline programming, and analysis, employs the DHM convention for its robot models. You can view and interact with the UR5e robot model in RoboDK's online library at \href{https://robodk.com/library }{RoboDK Robot Library}.

\begin{samepage}
\begin{lstlisting}[language=Python]
import numpy as np
from scipy.spatial.transform import Rotation as R

# DHM parameters for UR5e (in mm and rad)
a = [0, 0, 425, 392.25, 0, 0]
alpha = [0, np.pi/2, 0, 0, -np.pi/2, np.pi/2]
d = [162.5, 0, 0, 133.3, 99.7, 99.6]
theta_offsets = [0, np.pi, 0, 0, 0, np.pi]

# Given joint angles in degrees
joint_angles_deg = [0, -90, -90, 0, 90, 0]
joint_angles_rad = np.deg2rad(joint_angles_deg)

# Add offsets to joint angles
theta = joint_angles_rad + theta_offsets

# Function to compute DH transformation matrix
def dh_transform(a, alpha, d, theta):
    T = np.eye(4)
    # Trans_x(a)
    T[0, 3] = a
    # Rot_x(alpha)
    T[:3, :3] = R.from_rotvec([alpha, 0, 0]).as_matrix()
    # Trans_z(d)
    T_z = np.eye(4)
    T_z[2, 3] = d
    T = T @ T_z
    # Rot_z(theta)
    T_theta = np.eye(4)
    T_theta[:3, :3] = R.from_rotvec([0, 0, theta]).as_matrix()
    T = T @ T_theta
    return T

# Compute total transformation
T_total = np.eye(4)
for i in range(6):
    T_i = dh_transform(a[i], alpha[i], d[i], theta[i])
    T_total = T_total @ T_i

print("End-effector transformation matrix:")
print(T_total)
\end{lstlisting}

The expected output is:

\begin{lstlisting}[language=Python]
[[ 0.   0.   1. 491.85]
 [-1.   0.   0. -133.30]
 [ 0.  -1.   0. 687.20]
 [ 0.   0.   0.   1.]]
\end{lstlisting}
\end{samepage}

\begin{figure}[h]
	\centering
	\subfloat[RoboDK software GUI.]{\includegraphics[width=0.8\textwidth]{imgs/RoboDK.png}} \\
	\subfloat[UR5e robot with DHM parameters in RoboDK.]{\includegraphics[width=0.8\textwidth]{imgs/UR5e_RoboDK.png}}
	\caption{RoboDK software interface (top) and UR5e robot model with DHM parameters (bottom).}
	\label{fig:robodk_ur5e}
\end{figure}






